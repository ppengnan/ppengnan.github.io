<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æ‰‹åŠ¿çƒŸèŠ±</title>
<style>
body { 
    margin:0; 
    padding:0; 
    width:100vw; 
    height:100vh; 
    overflow:hidden; 
    display:flex; 
    justify-content:center; 
    align-items:center; 
    background: #000;
}
.wrapper { 
    position:relative; 
    width:100%; 
    height:100%; 
    overflow:hidden; 
}
#videoEl { 
    position:absolute; 
    width:100%; 
    height:100%; 
    object-fit:cover; 
    transform:scaleX(-1);
    opacity: 1;
    z-index: 0;
}
#drawCanvas { 
    position:absolute; 
    top:0; 
    left:0; 
    width:100%; 
    height:100%; 
    transform:scaleX(-1); 
    pointer-events:none;
    z-index: 2;
}
#fireworkCanvas { 
    position:absolute; 
    top:0; 
    left:0; 
    width:100%; 
    height:100%; 
    pointer-events:none; 
    z-index:1; 
}
#info { 
    position:absolute; 
    top:20px; 
    left:20px; 
    color:#fff; 
    background-color:rgba(0,0,0,0.7); 
    padding:15px; 
    border-radius:10px; 
    font-family:'Arial',sans-serif; 
    z-index:10;
    font-size: 14px;
    line-height: 1.6;
}
#info .status { 
    font-weight: bold; 
    color: #00ff88;
}
#info .hint {
    color: #ffaa00;
    margin-top: 5px;
}
</style>
</head>
<body>
<div class="wrapper">
    <video id="videoEl" autoplay playsinline></video>
    <canvas id="fireworkCanvas"></canvas>
    <canvas id="drawCanvas"></canvas>
    <div id="info">
        <div class="status">æ­£åœ¨åŠ è½½...</div>
        <div class="hint">ğŸ‘Œ æåˆé£ŸæŒ‡å’Œæ‹‡æŒ‡ï¼Œç„¶ååˆ†å¼€æ¥æ”¾çƒŸèŠ±ï¼</div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
document.addEventListener('DOMContentLoaded',()=>{

const vid=document.getElementById('videoEl');
const drawCanvas=document.getElementById('drawCanvas');
const drawCtx=drawCanvas.getContext('2d');
const fwCanvas=document.getElementById('fireworkCanvas');
const fwCtx=fwCanvas.getContext('2d');
const status=document.getElementById('info');

let fireworks = [];
let particles = [];
let isPinched = false;
let lastPinchDist = 0;
let fingerPos = {x: 0, y: 0};

function resizeCanvas(){ 
    drawCanvas.width=window.innerWidth; 
    drawCanvas.height=window.innerHeight; 
    fwCanvas.width=window.innerWidth; 
    fwCanvas.height=window.innerHeight; 
}

window.addEventListener('resize',resizeCanvas);
resizeCanvas();

// çƒŸèŠ±ç²’å­ç±»
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 6 + 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1;
        this.decay = Math.random() * 0.015 + 0.01;
        this.size = Math.random() * 3 + 2;
        this.gravity = 0.05;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += this.gravity;
        this.vx *= 0.99;
        this.vy *= 0.99;
        this.life -= this.decay;
    }
    
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        // æ·»åŠ å‘å…‰æ•ˆæœ
        ctx.globalAlpha = this.life * 0.5;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

// åˆ›å»ºçƒŸèŠ±
function createFirework(x, y) {
    const colors = [
        '#ff0040', '#ff8800', '#ffff00', '#00ff88', 
        '#00ffff', '#0088ff', '#8800ff', '#ff00ff'
    ];
    const color = colors[Math.floor(Math.random() * colors.length)];
    const particleCount = Math.random() * 50 + 100;
    
    for(let i = 0; i < particleCount; i++) {
        particles.push(new Particle(x, y, color));
    }
    
    // æ·»åŠ ç¬¬äºŒå±‚æ›´å°çš„ç²’å­
    for(let i = 0; i < particleCount / 2; i++) {
        const p = new Particle(x, y, '#ffffff');
        p.size *= 0.5;
        particles.push(p);
    }
}

// åŠ¨ç”»å¾ªç¯
function animate() {
    // ä½¿ç”¨åŠé€æ˜é»‘è‰²è¦†ç›–ï¼Œäº§ç”Ÿæ‹–å°¾æ•ˆæœ
    // fwCtx.fillStyle = 'rgba(10, 14, 39, 0.2)';
    // fwCtx.fillRect(0, 0, fwCanvas.width, fwCanvas.height);
    fwCtx.clearRect(0, 0, fwCanvas.width, fwCanvas.height);
    // æ›´æ–°å’Œç»˜åˆ¶ç²’å­
    for(let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        particles[i].draw(fwCtx);
        
        if(particles[i].life <= 0) {
            particles.splice(i, 1);
        }
    }
    
    requestAnimationFrame(animate);
}

async function initCamera(){
    const stream=await navigator.mediaDevices.getUserMedia({
        video:{
            width:{ideal:1280},
            height:{ideal:720},
            facingMode:'user'
        }
    });
    vid.srcObject=stream;
    return new Promise(res=>{
        vid.onloadedmetadata=()=>{
            resizeCanvas(); 
            res(vid);
        };
    });
}

function dist(p1, p2) { 
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    const dz = (p1.z || 0) - (p2.z || 0);
    return Math.sqrt(dx * dx + dy * dy + dz * dz); 
}

function drawHand(lms) {
    const sz = Math.min(window.innerWidth, window.innerHeight);
    const lw = Math.max(2, Math.min(4, sz / 300));
    const ps = Math.max(3, Math.min(8, sz / 250));
    
    const conns = [
        [0,1],[1,2],[2,3],[3,4],
        [0,5],[5,6],[6,7],[7,8],
        [0,9],[9,10],[10,11],[11,12],
        [0,13],[13,14],[14,15],[15,16],
        [0,17],[17,18],[18,19],[19,20]
    ];
    
    drawCtx.lineWidth = lw;
    drawCtx.strokeStyle = '#00ff88';
    drawCtx.lineCap = 'round';
    drawCtx.lineJoin = 'round';
    
    // ç»˜åˆ¶è¿æ¥çº¿
    conns.forEach(([i,j]) => { 
        const s = lms[i];
        const e = lms[j]; 
        drawCtx.beginPath(); 
        drawCtx.moveTo(s.x * drawCanvas.width, s.y * drawCanvas.height); 
        drawCtx.lineTo(e.x * drawCanvas.width, e.y * drawCanvas.height); 
        drawCtx.stroke(); 
    });
    
    // ç»˜åˆ¶å…³é”®ç‚¹
    lms.forEach((lm, idx) => { 
        let color = '#00ff88';
        if(idx === 4) color = '#ff0040'; // æ‹‡æŒ‡
        if(idx === 8) color = '#ffff00'; // é£ŸæŒ‡
        
        drawCtx.fillStyle = color;
        drawCtx.beginPath(); 
        drawCtx.arc(lm.x * drawCanvas.width, lm.y * drawCanvas.height, ps, 0, 2 * Math.PI); 
        drawCtx.fill();
        
        // å‘å…‰æ•ˆæœ
        drawCtx.fillStyle = color + '44';
        drawCtx.beginPath(); 
        drawCtx.arc(lm.x * drawCanvas.width, lm.y * drawCanvas.height, ps * 2, 0, 2 * Math.PI); 
        drawCtx.fill();
    });
}

async function setupHands(){
    status.querySelector('.status').textContent = 'æ­£åœ¨åŠ è½½æ‰‹éƒ¨è¯†åˆ«...';
    const hands = new Hands({
        locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.5
    });
    await hands.initialize();
    status.querySelector('.status').textContent = 'âœ“ å‡†å¤‡å°±ç»ª';
    return hands;
}

function processHands(results) {
    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
    
    if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const lm = results.multiHandLandmarks[0];
        drawHand(lm);
        
        const thumb = lm[4];  // æ‹‡æŒ‡å°–
        const index = lm[8];  // é£ŸæŒ‡å°–
        
        // è®¡ç®—æ‹‡æŒ‡å’Œé£ŸæŒ‡çš„è·ç¦»
        const pinchDist = dist(thumb, index);
        
        // è®¡ç®—æ‰‹æŒ‡ä¸­å¿ƒä½ç½®ï¼ˆå±å¹•åæ ‡ï¼Œéœ€è¦ç¿»è½¬xè½´ï¼‰
        const centerX = (1 - (thumb.x + index.x) / 2) * drawCanvas.width;
        const centerY = (thumb.y + index.y) / 2 * drawCanvas.height;
        fingerPos = {x: centerX, y: centerY};
        
        // æåˆé˜ˆå€¼
        const pinchThreshold = 0.05;
        const releaseThreshold = 0.15;
        
        if(pinchDist < pinchThreshold && !isPinched) {
            // å¼€å§‹æåˆ
            isPinched = true;
            lastPinchDist = pinchDist;
            status.querySelector('.status').textContent = 'ğŸ¤ å·²æåˆ - æ¾å¼€æ”¾çƒŸèŠ±ï¼';
        } else if(isPinched && pinchDist > releaseThreshold) {
            // æ¾å¼€è§¦å‘çƒŸèŠ±
            createFirework(fingerPos.x, fingerPos.y);
            isPinched = false;
            status.querySelector('.status').textContent = 'ğŸ† çƒŸèŠ±ç»½æ”¾ï¼';
            setTimeout(() => {
                status.querySelector('.status').textContent = 'âœ“ å‡†å¤‡å°±ç»ª';
            }, 1000);
        } else if(isPinched) {
            status.querySelector('.status').textContent = `ğŸ¤ æåˆä¸­ (${Math.round((releaseThreshold - pinchDist) * 100)}%)`;
        }
        
        // åœ¨æ‰‹æŒ‡ä½ç½®ç»˜åˆ¶æŒ‡ç¤ºå™¨
           //if(isPinched) {
              // drawCtx.save();
              // drawCtx.strokeStyle = '#ffff00';
              // drawCtx.lineWidth = 3;
              // drawCtx.beginPath();
              // drawCtx.arc(centerX, centerY, 30, 0, Math.PI * 2);
              // drawCtx.stroke();
            
              // drawCtx.fillStyle = '#ffff0044';
             //  drawCtx.beginPath();
             //  drawCtx.arc(centerX, centerY, 25, 0, Math.PI * 2);
              // drawCtx.fill();
              // drawCtx.restore();
          // }
        
    } else { 
        status.querySelector('.status').textContent = 'ğŸ‘‹ è¯·å°†æ‰‹æ”¾å…¥ç”»é¢';
        isPinched = false;
    }
}

async function runApp() {
    try {
        await initCamera();
        const hands = await setupHands();
        hands.onResults(processHands);
        
        const camMP = new Camera(vid, {
            onFrame: async () => {
                await hands.send({image: vid});
            }, 
            width: 1280,
            height: 720
        });
        
        camMP.start();
        animate(); // å¯åŠ¨çƒŸèŠ±åŠ¨ç”»å¾ªç¯
        
    } catch(e) { 
        status.querySelector('.status').textContent = `âŒ é”™è¯¯: ${e.message}`;
        console.error(e);
    }
}

runApp();
});
</script>
</body>
</html>
