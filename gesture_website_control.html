<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ğŸ‘‹ Gesture Control Mode (Pinch Drag Scroll)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: Arial, sans-serif;
    }
    
    #video-container {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 320px;
      height: 240px;
      border: 3px solid #00ff00;
      border-radius: 10px;
      overflow: hidden;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    
    #input_video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
    }
    
    #output_canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
    }
    
    #website-frame {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
    }
    
    #cursor {
      position: fixed;
      width: 40px;
      height: 40px;
      background-image: url('./arrow.png');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      pointer-events: none;
      z-index: 999;
      display: none;
      transition: transform 0.1s;
      transform-origin: top left;
    }

    #cursor.clicking {
      transform: scale(1.3);
    }

    /* æä½ä¸€å®šæ—¶é—´è§¦å‘æ»šåŠ¨æ—¶çš„ 1cm åœ†åœˆ */
    #pinch-circle {
      position: fixed;
      width: 40px;   /* çº¦ 1cm */
      height: 40px;  /* çº¦ 1cm */
      border-radius: 50%;
      border: 2px solid rgba(0, 255, 0, 0.8);
      pointer-events: none;
      z-index: 998;
      display: none;
      box-sizing: border-box;
    }
    
    #info-panel {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      z-index: 1000;
      font-size: 14px;
      max-width: 300px;
    }
    
    .gesture-info {
      margin: 5px 0;
    }
    
    .gesture-info strong {
      color: #00ff00;
    }
    
    #exit-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      z-index: 1101;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.75);
      color: #fff;
      border-radius: 999px;
      text-decoration: none;
      font-size: 12px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      transition: background 0.2s ease, transform 0.1s ease;
    }
  </style>
</head>
<body>
  <iframe id="website-frame" src="https://ppengnan.github.io/"></iframe>
  <div id="cursor"></div>
  <!-- ç”¨äºæ˜¾ç¤º 1cm åœ†åœˆ -->
  <div id="pinch-circle"></div>
  
  <div id="video-container">
    <a href="/" id="exit-btn">â† Exit Gesture Mode</a>
    <video id="input_video" autoplay playsinline muted></video>
    <canvas id="output_canvas"></canvas>
  </div>
  
  <div id="info-panel">
    <div class="gesture-info"><strong>Gesture Control:</strong></div>
    <div class="gesture-info">âœ‹ Spread your palm - Move the cursor</div>
    <div class="gesture-info">ğŸ¤ Pinch â‰¥ 0.5s + drag â€“ Scroll the page</div>
    <div class="gesture-info">ğŸ¤ Pinch &lt; 0.5s â€“ Click</div>
    <div class="gesture-info" id="status">Status: Waiting for detectionâ€¦</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const cursor = document.getElementById('cursor');
    const statusElement = document.getElementById('status');
    const pinchCircle = document.getElementById('pinch-circle');
    
    function resizeCanvas() {
      const container = document.getElementById('video-container');
      canvasElement.width = container.clientWidth;
      canvasElement.height = container.clientHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    
    let clickCooldown = false;

    // 1ç§’é˜ˆå€¼ + 1cm åœ†åœˆå°ºå¯¸
    const PINCH_FRAMES_REQUIRED = 3;
    const PINCH_DISTANCE_THRESHOLD = 0.045;
    const SCROLL_SPEED = 6;             // æ”¹å°ï¼šè®©æ»‘åŠ¨æ›´æ…¢æ›´ç¨³
    const SCROLL_ACTIVATE_TIME = 500;   // msï¼Œæä½ >= 1 ç§’è¿›å…¥æ»šåŠ¨æ¨¡å¼
    const CIRCLE_DIAMETER_PX = 40;      // çº¦ 1cmï¼ˆå±å¹•ä¸Šï¼‰
    const CIRCLE_RADIUS_PX = CIRCLE_DIAMETER_PX / 2;

    // ç‚¹å‡»å®¹é”™åŒºåŸŸï¼ˆç­–ç•¥5ï¼‰
    const CLICK_SEARCH_RADIUS = 25;     // å…‰æ ‡é™„è¿‘æœç´¢åŠå¾„ï¼Œåƒç´ 
    const CLICK_SEARCH_STEP = 5;        // æœç´¢æ­¥é•¿ï¼Œåƒç´ 

    const pinchState = {
      Left:  { 
        isPinching: false, 
        frameCount: 0, 
        lastY: null, 
        startY: null, 
        startTime: null, 
        moved: false, 
        smoothY: null,
        mode: 'idle',           // 'idle' | 'pending' | 'scroll'
        circleActive: false,
        circleCenterX: null,
        circleCenterY: null,
        lastScrollY: null
      },
      Right: { 
        isPinching: false, 
        frameCount: 0, 
        lastY: null, 
        startY: null, 
        startTime: null, 
        moved: false, 
        smoothY: null,
        mode: 'idle',
        circleActive: false,
        circleCenterX: null,
        circleCenterY: null,
        lastScrollY: null
      }
    };

    function getDistance(point1, point2) {
      return Math.sqrt(
        Math.pow(point1.x - point2.x, 2) + 
        Math.pow(point1.y - point2.y, 2)
      );
    }

    // æåˆäº¤ç‚¹ï¼ˆæ‹‡æŒ‡ä¸é£ŸæŒ‡ä¸­ç‚¹ï¼‰åæ ‡
    function recognizeGesture(landmarks) {
      const thumbTip  = landmarks[4];
      const indexTip  = landmarks[8];
      const indexBase = landmarks[5];
      const middleTip = landmarks[12];
      const ringTip   = landmarks[16];
      const pinkyTip  = landmarks[20];
      const middleBase = landmarks[9];
      const ringBase   = landmarks[13];
      const pinkyBase  = landmarks[17];

      const pinchDistance = getDistance(thumbTip, indexTip);
      const indexStraight = (indexBase.y - indexTip.y) > 0.05;
      const allExtended = indexStraight && (middleTip.y < middleBase.y) && (ringTip.y < ringBase.y) && (pinkyTip.y < pinkyBase.y);

      // æåˆäº¤ç‚¹ï¼ˆå½’ä¸€åŒ–åæ ‡ï¼‰
      const pinchX = (thumbTip.x + indexTip.x) / 2;
      const pinchY = (thumbTip.y + indexTip.y) / 2;

      return {
        pinchDistance,
        indexTip,
        indexStraight,
        allExtended,
        pinchX,
        pinchY
      };
    }

    function performGestureForHand(handedness, gestureData) {
      const state = pinchState[handedness];
      const pinchDistance = gestureData.pinchDistance;
      const allExtended = gestureData.allExtended;
      const indexStraight = gestureData.indexStraight;

      // ä½¿ç”¨æåˆäº¤ç‚¹æ§åˆ¶å…‰æ ‡å’Œåœ†åœˆä½ç½®
      const x = (1 - gestureData.pinchX) * window.innerWidth;
      const y = gestureData.pinchY * window.innerHeight;

      cursor.style.left = x + 'px';
      cursor.style.top = y + 'px';
      cursor.style.display = 'block';

      // æ£€æµ‹æ˜¯å¦åœ¨æåˆï¼ˆè·ç¦»é˜ˆå€¼+è¿ç»­å¸§ï¼‰
      if (pinchDistance < PINCH_DISTANCE_THRESHOLD) {
        state.frameCount++;
      } else {
        state.frameCount = 0;
      }

      // åˆšè¿›å…¥æåˆçŠ¶æ€ï¼ˆå¼€å§‹è®¡æ—¶ï¼‰
      if (!state.isPinching && state.frameCount >= PINCH_FRAMES_REQUIRED) {
        state.isPinching = true;
        state.startY = y;
        state.lastY = y;
        state.smoothY = y;
        state.startTime = performance.now();
        state.moved = false;
        state.mode = 'pending';       // è¿˜æ²¡åˆ° 1 ç§’ï¼Œç­‰å¾…å†³å®šæ˜¯ç‚¹å‡»è¿˜æ˜¯æ»šåŠ¨
        state.circleActive = false;
        state.circleCenterX = null;
        state.circleCenterY = null;
        state.lastScrollY = null;
        pinchCircle.style.display = 'none';
        statusElement.textContent = `Status: ${handedness} hand pinching`;
      }

      // å¤„äºæåˆçŠ¶æ€
      if (state.isPinching) {
        const now = performance.now();
        state.lastY = y;

        // å¹³æ»‘ Yï¼ˆç”¨äºæ»šåŠ¨æ›´ç¨³ï¼‰
        if (state.smoothY === null) {
          state.smoothY = y;
        } else {
          state.smoothY = state.smoothY * 0.7 + y * 0.3;
        }

        const elapsed = now - state.startTime;

        // æ»¡ 1 ç§’ï¼Œè¿›å…¥æ»šåŠ¨æ¨¡å¼ï¼Œæ˜¾ç¤ºåœ†åœˆ
        if (elapsed >= SCROLL_ACTIVATE_TIME && state.mode === 'pending') {
          state.mode = 'scroll';
          state.circleActive = true;
          state.circleCenterX = x;
          state.circleCenterY = y;
          state.lastScrollY = y;

          pinchCircle.style.display = 'block';
          pinchCircle.style.left = (x - CIRCLE_RADIUS_PX) + 'px';
          pinchCircle.style.top  = (y - CIRCLE_RADIUS_PX) + 'px';
          pinchCircle.style.width  = CIRCLE_DIAMETER_PX + 'px';
          pinchCircle.style.height = CIRCLE_DIAMETER_PX + 'px';

          statusElement.textContent = `Status: ${handedness} hand scroll mode`;
        }

        // æ»šåŠ¨æ¨¡å¼ï¼šæåˆäº¤ç‚¹ç›¸å¯¹åœ†åœˆä¸­å¿ƒç§»åŠ¨è¶…å‡º 1cm æ‰æ»šåŠ¨é¡µé¢
        if (state.mode === 'scroll' && state.circleActive) {
          const dyFromCircle = y - state.circleCenterY;

          if (Math.abs(dyFromCircle) > CIRCLE_RADIUS_PX) {
            const frame = document.getElementById('website-frame');
            const scrollDelta = (state.smoothY - state.lastScrollY) * SCROLL_SPEED;

            if (frame && frame.contentWindow) {
              try {
                frame.contentWindow.scrollBy(0, scrollDelta);
              } catch (e) {
                window.scrollBy(0, scrollDelta);
              }
            } else {
              window.scrollBy(0, scrollDelta);
            }

            state.moved = true;
            state.lastScrollY = state.smoothY;

            // åœ†åœˆè·Ÿéšæåˆç‚¹ç§»åŠ¨ï¼ˆæ¯æ¬¡æ»šåŠ¨åæ›´æ–°åœ†å¿ƒï¼Œå½¢æˆâ€œæ­»åŒºâ€ï¼‰
            state.circleCenterX = x;
            state.circleCenterY = y;
            pinchCircle.style.left = (state.circleCenterX - CIRCLE_RADIUS_PX) + 'px';
            pinchCircle.style.top  = (state.circleCenterY - CIRCLE_RADIUS_PX) + 'px';

            statusElement.textContent = `Status: ${handedness} scrolling`;
          } else {
            statusElement.textContent = `Status: ${handedness} pinch inside circle (no scroll)`;
          }
        }
      }

      // æ²¡æœ‰å¤„äºæåˆä¸­æ—¶çš„çŠ¶æ€æç¤º
      if (!state.isPinching) {
        if (allExtended) {
          statusElement.textContent = 'Status: Move the cursor (palm)';
          cursor.className = '';
        } else if (indexStraight) {
          statusElement.textContent = 'Status: Index up (no scroll - now use pinch)';
        } else {
          statusElement.textContent = 'Status: Waiting for gestureâ€¦';
        }
      }
    }

    // æ ¹æ®æåˆæŒç»­æ—¶é—´åˆ¤æ–­ç‚¹å‡»ï¼ˆ<1sï¼‰è¿˜æ˜¯æ»šåŠ¨ç»“æŸï¼ˆ>=1sï¼‰
    function handlePinchEnd(handedness) {
      const state = pinchState[handedness];
      if (!state.isPinching) return;

      const now = performance.now();
      const duration = state.startTime ? (now - state.startTime) : 0;

      if (state.mode === 'pending' && duration < SCROLL_ACTIVATE_TIME) {
        // æä½ä¸åˆ° 1 ç§’ï¼šè§†ä¸ºç‚¹å‡»
        triggerClickAtCursor();
        statusElement.textContent = `Status: ${handedness} click (pinch < 1s)`;
      } else {
        // å·²ç»è¿›å…¥æ»šåŠ¨æ¨¡å¼ï¼šåªç»“æŸæ»šåŠ¨ï¼Œä¸è§¦å‘ç‚¹å‡»
        statusElement.textContent = `Status: ${handedness} pinch ended`;
      }

      state.isPinching = false;
      state.frameCount = 0;
      state.lastY = null;
      state.startY = null;
      state.smoothY = null;
      state.startTime = null;
      state.moved = false;
      state.mode = 'idle';
      state.circleActive = false;
      state.circleCenterX = null;
      state.circleCenterY = null;
      state.lastScrollY = null;

      pinchCircle.style.display = 'none';
    }

    // åœ¨ iframe å†…éƒ¨ï¼Œä»¥ (x, y) ä¸ºä¸­å¿ƒï¼Œåœ¨ä¸€ä¸ªå°æ–¹å½¢åŒºåŸŸå†…æœç´¢æœ€è¿‘çš„å¯ç‚¹å‡»å…ƒç´ 
    function findBestClickableInIframe(iframeDoc, x, y) {
      let bestElement = null;
      let bestDistance = Infinity;

      for (let dx = -CLICK_SEARCH_RADIUS; dx <= CLICK_SEARCH_RADIUS; dx += CLICK_SEARCH_STEP) {
        for (let dy = -CLICK_SEARCH_RADIUS; dy <= CLICK_SEARCH_RADIUS; dy += CLICK_SEARCH_STEP) {
          const testX = x + dx;
          const testY = y + dy;
          const el = iframeDoc.elementFromPoint(testX, testY);
          if (!el) continue;

          // é™å®šå¯ç‚¹å‡»å…ƒç´ ï¼šaã€buttonã€role="button"ã€æœ‰ onclick çš„å…ƒç´ 
          const clickable = el.closest('a, button, [role="button"], [onclick]');
          if (!clickable) continue;

          const dist = Math.hypot(dx, dy);
          if (dist < bestDistance) {
            bestDistance = dist;
            bestElement = clickable;
          }
        }
      }

      return bestElement;
    }

    function triggerClickAtCursor() {
      if (clickCooldown) return;
      const frame = document.getElementById('website-frame');
      const frameRect = frame.getBoundingClientRect();
      const cx = parseFloat(cursor.style.left || 0);
      const cy = parseFloat(cursor.style.top || 0);
      const iframeX = cx - frameRect.left;
      const iframeY = cy - frameRect.top;

      if (frame && frame.contentWindow) {
        try {
          const iframeDoc = frame.contentWindow.document;

          // å…ˆåœ¨é™„è¿‘åŒºåŸŸæ‰¾â€œæœ€è¿‘çš„å¯ç‚¹å‡»å…ƒç´ â€ï¼ˆç­–ç•¥5ï¼‰
          let targetElement = findBestClickableInIframe(iframeDoc, iframeX, iframeY);

          // å¦‚æœé™„è¿‘æ‰¾ä¸åˆ°ï¼Œå°±é€€å›åˆ°å…‰æ ‡æ­£ä¸‹æ–¹çš„å…ƒç´ 
          if (!targetElement) {
            const el = iframeDoc.elementFromPoint(iframeX, iframeY);
            if (el) {
              targetElement = el.closest('a, button, [role="button"], [onclick]') || el;
            }
          }
          
          if (targetElement) {
            const rect = targetElement.getBoundingClientRect();
            const clickEvent = new MouseEvent('click', {
              bubbles: true,
              cancelable: true,
              view: frame.contentWindow,
              // ç”¨å…ƒç´ ä¸­å¿ƒç‚¹å‘ç‚¹å‡»ï¼Œæ›´ç¨³ä¸€ç‚¹
              clientX: rect.left + rect.width / 2,
              clientY: rect.top + rect.height / 2
            });
            targetElement.dispatchEvent(clickEvent);
          }
        } catch (e) {
          console.warn('Cross-origin restrictions prevent access to iframe content:', e);
        }
      }

      cursor.className = 'clicking';
      clickCooldown = true;
      setTimeout(() => {
        clickCooldown = false;
        cursor.className = '';
      }, 400);
    }

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    
    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.5
    });
    
    hands.onResults(results => {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
      
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        for (let i = 0; i < results.multiHandLandmarks.length; i++) {
          const landmarks = results.multiHandLandmarks[i];
          drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
            color: '#0000FF', 
            lineWidth: 1
          });
          drawLandmarks(canvasCtx, landmarks, {
            color: '#FF0000', 
            lineWidth: 1,
            radius: 1.5
          });
        }

        for (let i = 0; i < results.multiHandLandmarks.length; i++) {
          const landmarks = results.multiHandLandmarks[i];
          const rawHandedness = (results.multiHandedness && results.multiHandedness[i] && results.multiHandedness[i].label) || 'Right';
          // é•œåƒåå·¦å³ä¼šåï¼Œæ‰€ä»¥è¿™é‡Œåšäº†è½¬æ¢
          const handedness = rawHandedness === 'Left' ? 'Right' : 'Left';
          const g = recognizeGesture(landmarks);
          performGestureForHand(handedness, g);
        }
      } else {
        // æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹æ—¶ï¼Œç»“æŸä¸¤åªæ‰‹çš„æåˆçŠ¶æ€
        handlePinchEnd('Left');
        handlePinchEnd('Right');
        cursor.style.display = 'none';
        statusElement.textContent = 'Status: Waiting for detectionâ€¦';
      }
      
      canvasCtx.restore();
    });
    
    const camera = new Camera(videoElement, {
      onFrame: async () => await hands.send({image: videoElement}),
      width: 640,
      height: 480
    });
    camera.start();

    // å¦‚æœæ£€æµ‹åˆ°æåˆç»“æŸï¼ˆframeCount å½’é›¶ï¼‰ï¼Œåˆ™è°ƒç”¨ handlePinchEnd
    setInterval(() => {
      ['Left','Right'].forEach(h => {
        const s = pinchState[h];
        if (s.isPinching && s.frameCount === 0) {
          handlePinchEnd(h);
        }
      });
    }, 80);

  </script>
</body>
</html>
