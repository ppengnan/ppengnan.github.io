<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ğŸ‘‹ Gesture Control Mode (Pinch Drag Scroll)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: Arial, sans-serif;
    }
    
    #video-container {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 320px;
      height: 240px;
      border: 3px solid #00ff00;
      border-radius: 10px;
      overflow: hidden;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    
    #input_video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
    }
    
    #output_canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
    }
    
    #website-frame {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
    }
    
    #cursor {
      position: fixed;
      width: 40px;
      height: 40px;
      background-image: url('./arrow.png');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      pointer-events: none;
      z-index: 999;
      display: none;
      transition: transform 0.1s;
      transform-origin: top left;
    }

    #cursor.clicking {
      transform: scale(1.3);
    }
    
    #info-panel {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      z-index: 1000;
      font-size: 14px;
      max-width: 300px;
    }
    
    .gesture-info {
      margin: 5px 0;
    }
    
    .gesture-info strong {
      color: #00ff00;
    }
    
    #exit-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      z-index: 1101;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.75);
      color: #fff;
      border-radius: 999px;
      text-decoration: none;
      font-size: 12px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      transition: background 0.2s ease, transform 0.1s ease;
    }
  </style>
</head>
<body>
  <iframe id="website-frame" src="https://ppengnan.github.io/"></iframe>
  <div id="cursor"></div>
  
  <div id="video-container">
    <a href="/" id="exit-btn">â† Exit Gesture Mode</a>
    <video id="input_video" autoplay playsinline muted></video>
    <canvas id="output_canvas"></canvas>
  </div>
  
  <div id="info-panel">
    <div class="gesture-info"><strong>Gesture Control:</strong></div>
    <div class="gesture-info">âœ‹ Spread your palm - Move the cursor</div>
    <div class="gesture-info">ğŸ¤ Pinch + drag â€“ Scroll the page (like Vision Pro)</div>
    <div class="gesture-info">ğŸ¤ Short pinch (quick) â€“ Click</div>
    <div class="gesture-info" id="status">Status: Waiting for detectionâ€¦</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const cursor = document.getElementById('cursor');
    const statusElement = document.getElementById('status');
    
    function resizeCanvas() {
      const container = document.getElementById('video-container');
      canvasElement.width = container.clientWidth;
      canvasElement.height = container.clientHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    
    let clickCooldown = false;

    const pinchState = {
      Left:  { isPinching: false, frameCount: 0, lastY: null, startY: null, startTime: null, moved: false, smoothY: null, initialScrollY: 0 },
      Right: { isPinching: false, frameCount: 0, lastY: null, startY: null, startTime: null, moved: false, smoothY: null, initialScrollY: 0 }
    };

    const PINCH_FRAMES_REQUIRED = 2;
    const PINCH_DISTANCE_THRESHOLD = 0.04;
    const SCROLL_SENSITIVITY = 2.5;  // æ‰‹ç§»åŠ¨1pxï¼Œé¡µé¢æ»šåŠ¨2.5px
    const CLICK_MAX_DURATION = 250;
    const CLICK_MAX_MOVE = 20;

    function getDistance(point1, point2) {
      return Math.sqrt(
        Math.pow(point1.x - point2.x, 2) + 
        Math.pow(point1.y - point2.y, 2)
      );
    }

    function recognizeGesture(landmarks) {
      const thumbTip  = landmarks[4];
      const indexTip  = landmarks[8];
      const indexBase = landmarks[5];
      const middleTip = landmarks[12];
      const ringTip   = landmarks[16];
      const pinkyTip  = landmarks[20];
      const middleBase = landmarks[9];
      const ringBase   = landmarks[13];
      const pinkyBase  = landmarks[17];

      const pinchDistance = getDistance(thumbTip, indexTip);
      const indexStraight = (indexBase.y - indexTip.y) > 0.05;
      const allExtended = indexStraight && (middleTip.y < middleBase.y) && (ringTip.y < ringBase.y) && (pinkyTip.y < pinkyBase.y);
      return {
        pinchDistance,
        indexTip,
        indexStraight,
        allExtended
      };
    }

    function performGestureForHand(handedness, gestureData) {
      const state = pinchState[handedness];
      const indexTip = gestureData.indexTip;
      const pinchDistance = gestureData.pinchDistance;
      const allExtended = gestureData.allExtended;
      const indexStraight = gestureData.indexStraight;

      const x = (1 - indexTip.x) * window.innerWidth;
      const y = indexTip.y * window.innerHeight;

      cursor.style.left = x + 'px';
      cursor.style.top = y + 'px';
      cursor.style.display = 'block';

      if (pinchDistance < PINCH_DISTANCE_THRESHOLD) {
        state.frameCount++;
      } else {
        state.frameCount = 0;
      }

      if (!state.isPinching && state.frameCount >= PINCH_FRAMES_REQUIRED) {
        state.isPinching = true;
        state.startY = y;
        state.lastY = y;
        state.smoothY = y;
        state.startTime = performance.now();
        state.moved = false;
        
        // è®°å½•é¡µé¢åˆå§‹æ»šåŠ¨ä½ç½®
        const frame = document.getElementById('website-frame');
        try {
          state.initialScrollY = frame.contentWindow.scrollY || frame.contentWindow.pageYOffset || 0;
        } catch (e) {
          state.initialScrollY = window.scrollY || window.pageYOffset || 0;
        }
        
        statusElement.textContent = `Status: ${handedness} hand pinching - ready to scroll`;
      }

      if (state.isPinching) {
        // ç®€å•å¹³æ»‘ï¼ˆå‡å°‘æŠ–åŠ¨ï¼‰
        if (state.smoothY === null) {
          state.smoothY = y;
        } else {
          state.smoothY = state.smoothY * 0.6 + y * 0.4;
        }
        
        // Vision Pro é£æ ¼ï¼šè®¡ç®—ä»èµ·ç‚¹çš„æ€»ä½ç§»
        const totalDelta = state.smoothY - state.startY;
        
        // åªè¦æœ‰æ˜æ˜¾ç§»åŠ¨å°±æ ‡è®°
        if (Math.abs(totalDelta) > 5) {
          state.moved = true;
        }
        
        // è®¡ç®—ç›®æ ‡æ»šåŠ¨ä½ç½® = åˆå§‹ä½ç½® - æ‰‹çš„ä½ç§» * çµæ•åº¦
        const targetScrollY = state.initialScrollY - (totalDelta * SCROLL_SENSITIVITY);
        
        const frame = document.getElementById('website-frame');
        if (frame && frame.contentWindow) {
          try {
            // ç›´æ¥è®¾ç½®æ»šåŠ¨ä½ç½®ï¼ˆä¸æ˜¯å¢é‡ï¼‰
            frame.contentWindow.scrollTo(0, targetScrollY);
          } catch (e) {
            window.scrollTo(0, targetScrollY);
          }
        } else {
          window.scrollTo(0, targetScrollY);
        }
      }

      if (!state.isPinching) {
        if (allExtended) {
          statusElement.textContent = 'Status: Move the cursor (palm)';
          cursor.className = '';
        } else if (indexStraight) {
          statusElement.textContent = 'Status: Index up (no scroll - now use pinch drag)';
        } else {
          statusElement.textContent = 'Status: Waiting for gestureâ€¦';
        }
      }
    }

    function handlePinchEnd(handedness) {
      const state = pinchState[handedness];
      if (!state.isPinching) return;
      const duration = performance.now() - state.startTime;
      const totalMove = Math.abs(state.lastY - state.startY || 0);

      if (duration < CLICK_MAX_DURATION && !state.moved) {
        triggerClickAtCursor();
        statusElement.textContent = `Status: ${handedness} click`;
      } else {
        statusElement.textContent = `Status: ${handedness} pinch ended`;
      }

      state.isPinching = false;
      state.frameCount = 0;
      state.lastY = null;
      state.startY = null;
      state.smoothY = null;
      state.startTime = null;
      state.moved = false;
    }

    function triggerClickAtCursor() {
      if (clickCooldown) return;
      const frame = document.getElementById('website-frame');
      const frameRect = frame.getBoundingClientRect();
      const cx = parseFloat(cursor.style.left || 0);
      const cy = parseFloat(cursor.style.top || 0);
      const iframeX = cx - frameRect.left;
      const iframeY = cy - frameRect.top;

      if (frame && frame.contentWindow) {
        try {
          const iframeDoc = frame.contentWindow.document;
          const targetElement = iframeDoc.elementFromPoint(iframeX, iframeY);
          
          if (targetElement) {
            const clickEvent = new MouseEvent('click', {
              bubbles: true,
              cancelable: true,
              view: frame.contentWindow,
              clientX: iframeX,
              clientY: iframeY
            });
            targetElement.dispatchEvent(clickEvent);
          }
        } catch (e) {
          console.warn('Cross-origin restrictions prevent access to iframe content:', e);
        }
      }

      cursor.className = 'clicking';
      clickCooldown = true;
      setTimeout(() => {
        clickCooldown = false;
        cursor.className = '';
      }, 400);
    }

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    
    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.5
    });
    
    hands.onResults(results => {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
      
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        for (let i = 0; i < results.multiHandLandmarks.length; i++) {
          const landmarks = results.multiHandLandmarks[i];
          drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
            color: '#0000FF', 
            lineWidth: 1
          });
          drawLandmarks(canvasCtx, landmarks, {
            color: '#FF0000', 
            lineWidth: 1,
            radius: 1.5
          });
        }

        for (let i = 0; i < results.multiHandLandmarks.length; i++) {
          const landmarks = results.multiHandLandmarks[i];
          const rawHandedness = (results.multiHandedness && results.multiHandedness[i] && results.multiHandedness[i].label) || 'Right';
          const handedness = rawHandedness === 'Left' ? 'Right' : 'Left';
          const g = recognizeGesture(landmarks);
          performGestureForHand(handedness, g);
        }
      } else {
        handlePinchEnd('Left');
        handlePinchEnd('Right');
        cursor.style.display = 'none';
        statusElement.textContent = 'Status: Waiting for detectionâ€¦';
      }
      
      canvasCtx.restore();
    });
    
    const camera = new Camera(videoElement, {
      onFrame: async () => await hands.send({image: videoElement}),
      width: 640,
      height: 480
    });
    camera.start();

    setInterval(() => {
      ['Left','Right'].forEach(h => {
        const s = pinchState[h];
        if (s.isPinching && s.frameCount === 0) {
          handlePinchEnd(h);
        }
      });
    }, 80);

  </script>
</body>
</html>
