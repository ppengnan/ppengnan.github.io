<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ğŸ‘‹ Gesture Control Mode</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: Arial, sans-serif;
    }
    
    #video-container {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 320px;
      height: 240px;
      border: 3px solid #00ff00;
      border-radius: 10px;
      overflow: hidden;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    
    #input_video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
    }
    
    #output_canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
    }
    
    #website-frame {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
    }
    
    #cursor {
      position: fixed;
      width: 30px;
      height: 30px;
      border: 3px solid #ff0000;
      border-radius: 50%;
      pointer-events: none;
      z-index: 999;
      display: none;
      transition: transform 0.1s;
    }
    
    #cursor.clicking {
      background: rgba(255, 0, 0, 0.3);
      transform: scale(1.5);
    }
    
    #cursor.pinching {
      background: rgba(0, 255, 255, 0.3);
      border-color: #00ffff;
    }
    
    #info-panel {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      z-index: 1000;
      font-size: 14px;
      max-width: 300px;
    }
    
    .gesture-info {
      margin: 5px 0;
    }
    
    .gesture-info strong {
      color: #00ff00;
    }
    
    #exit-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      z-index: 1101;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.75);
      color: #fff;
      border-radius: 999px;
      text-decoration: none;
      font-size: 12px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      transition: background 0.2s ease, transform 0.1s ease;
    }
  </style>
</head>
<body>
  <iframe id="website-frame" src="https://ppengnan.github.io/"></iframe>
  <div id="cursor"></div>
  
  <div id="video-container">
    <a href="/" id="exit-btn">â† Exit Gesture Mode</a>
    <video id="input_video" autoplay playsinline muted></video>
    <canvas id="output_canvas"></canvas>
  </div>
  
  <div id="info-panel">
    <div class="gesture-info"><strong>æ‰‹åŠ¿æ§åˆ¶:</strong></div>
    <div class="gesture-info">âœ‹ å¼ å¼€æ‰‹æŒ - ç§»åŠ¨å…‰æ ‡</div>
    <div class="gesture-info">ğŸ¤ å¤šæŒ‡æåˆ+æ‹–åŠ¨ - æ»šåŠ¨é¡µé¢</div>
    <div class="gesture-info">ğŸ‘† æŒ‡å°–åŒå‡» - ç‚¹å‡»</div>
    <div class="gesture-info" id="status">çŠ¶æ€: ç­‰å¾…æ£€æµ‹...</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const cursor = document.getElementById('cursor');
    const statusElement = document.getElementById('status');
    
    function resizeCanvas() {
      const container = document.getElementById('video-container');
      canvasElement.width = container.clientWidth;
      canvasElement.height = container.clientHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    
    // æ‰‹åŠ¿çŠ¶æ€
    let lastScrollY = 0;
    let isPinching = false;
    
    // åŒå‡»æ£€æµ‹
    let lastTapTime = 0;
    let lastTapPosition = null;
    const DOUBLE_TAP_DELAY = 300; // åŒå‡»é—´éš”æ—¶é—´(ms)
    const TAP_DISTANCE_THRESHOLD = 0.05; // åŒå‡»ä½ç½®å®¹å·®
    
    // è®¡ç®—ä¸¤ç‚¹è·ç¦»
    function getDistance(point1, point2) {
      return Math.sqrt(
        Math.pow(point1.x - point2.x, 2) + 
        Math.pow(point1.y - point2.y, 2)
      );
    }
    
    // æ£€æµ‹å¤šä¸ªæ‰‹æŒ‡æ˜¯å¦æåœ¨ä¸€èµ·
    function detectMultiFingerPinch(landmarks) {
      const fingerTips = [
        landmarks[4],  // æ‹‡æŒ‡
        landmarks[8],  // é£ŸæŒ‡
        landmarks[12], // ä¸­æŒ‡
        landmarks[16], // æ— åæŒ‡
        landmarks[20]  // å°æŒ‡
      ];
      
      // è®¡ç®—æ‰€æœ‰æŒ‡å°–ä¹‹é—´çš„å¹³å‡è·ç¦»
      let totalDistance = 0;
      let pairCount = 0;
      
      for (let i = 0; i < fingerTips.length; i++) {
        for (let j = i + 1; j < fingerTips.length; j++) {
          totalDistance += getDistance(fingerTips[i], fingerTips[j]);
          pairCount++;
        }
      }
      
      const avgDistance = totalDistance / pairCount;
      
      // å¦‚æœå¹³å‡è·ç¦»å°äºé˜ˆå€¼ï¼Œè®¤ä¸ºæ˜¯æåˆçŠ¶æ€
      // é˜ˆå€¼å¯ä»¥æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´
      return avgDistance < 0.15;
    }
    
    // æ£€æµ‹æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´
    function isFingerExtended(landmarks, fingerIndex) {
      // fingerIndex: 8(é£ŸæŒ‡), 12(ä¸­æŒ‡), 16(æ— åæŒ‡), 20(å°æŒ‡)
      const tip = landmarks[fingerIndex];
      const base = landmarks[fingerIndex - 3];
      return tip.y < base.y;
    }
    
    // è¯†åˆ«æ‰‹åŠ¿
    function recognizeGesture(landmarks) {
      const indexTip = landmarks[8];
      
      // æ£€æµ‹æ˜¯å¦æåˆ
      const pinching = detectMultiFingerPinch(landmarks);
      
      // æ£€æµ‹æ‰‹æŒ‡ä¼¸å±•æƒ…å†µ
      const indexExtended = isFingerExtended(landmarks, 8);
      const middleExtended = isFingerExtended(landmarks, 12);
      const ringExtended = isFingerExtended(landmarks, 16);
      const pinkyExtended = isFingerExtended(landmarks, 20);
      
      const allExtended = indexExtended && middleExtended && ringExtended && pinkyExtended;
      
      // æ‰‹åŠ¿ä¼˜å…ˆçº§ï¼šæåˆæ»šåŠ¨ > å¼ å¼€ç§»åŠ¨ > å…¶ä»–
      if (pinching) {
        return { type: 'pinch_scroll', position: indexTip };
      }
      
      if (allExtended) {
        return { type: 'move', position: indexTip };
      }
      
      // å•æŒ‡ä¼¸å‡ºå¯ç”¨äºåŒå‡»
      if (indexExtended && !middleExtended && !ringExtended) {
        return { type: 'tap', position: indexTip };
      }
      
      return { type: 'none', position: indexTip };
    }
    
    // æ‰§è¡Œæ‰‹åŠ¿åŠ¨ä½œ
    function performGesture(gesture) {
      const x = (1 - gesture.position.x) * window.innerWidth;
      const y = gesture.position.y * window.innerHeight;
      
      cursor.style.left = x + 'px';
      cursor.style.top = y + 'px';
      cursor.style.display = 'block';
      
      switch (gesture.type) {
        case 'move':
          statusElement.textContent = 'çŠ¶æ€: ç§»åŠ¨å…‰æ ‡';
          cursor.className = '';
          isPinching = false;
          break;
          
        case 'pinch_scroll': {
          statusElement.textContent = 'çŠ¶æ€: æåˆæ»šåŠ¨';
          cursor.className = 'pinching';
          
          // ç¬¬ä¸€æ¬¡è¿›å…¥æåˆçŠ¶æ€ï¼Œè®°å½•åˆå§‹ä½ç½®
          if (!isPinching) {
            lastScrollY = y;
            isPinching = true;
            break;
          }
          
          // è®¡ç®—ç§»åŠ¨é‡
          const rawDelta = y - lastScrollY;
          
          // æŠ—æŠ–åŠ¨
          if (Math.abs(rawDelta) < 3) {
            break;
          }
          
          // æ»šåŠ¨é€Ÿåº¦
          const SCROLL_SPEED = 2.5;
          const scrollDelta = rawDelta * SCROLL_SPEED;
          
          lastScrollY = y;
          
          // æ»šåŠ¨iframe
          const frame = document.getElementById('website-frame');
          if (frame && frame.contentWindow) {
            frame.contentWindow.scrollBy(0, scrollDelta);
          }
          break;
        }
        
        case 'tap': {
          statusElement.textContent = 'çŠ¶æ€: å‡†å¤‡ç‚¹å‡»';
          cursor.className = '';
          isPinching = false;
          
          // åŒå‡»æ£€æµ‹
          const currentTime = Date.now();
          const currentPosition = { x: gesture.position.x, y: gesture.position.y };
          
          if (lastTapTime && (currentTime - lastTapTime) < DOUBLE_TAP_DELAY) {
            // æ£€æŸ¥ä½ç½®æ˜¯å¦æ¥è¿‘
            if (lastTapPosition && getDistance(currentPosition, lastTapPosition) < TAP_DISTANCE_THRESHOLD) {
              // è§¦å‘ç‚¹å‡»
              statusElement.textContent = 'çŠ¶æ€: åŒå‡»è§¦å‘!';
              cursor.className = 'clicking';
              
              const clickEvent = new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
                view: window,
                clientX: x,
                clientY: y
              });
              
              document.elementFromPoint(x, y)?.dispatchEvent(clickEvent);
              
              // é‡ç½®åŒå‡»çŠ¶æ€
              lastTapTime = 0;
              lastTapPosition = null;
              
              setTimeout(() => {
                cursor.className = '';
              }, 300);
              
              break;
            }
          }
          
          // è®°å½•æœ¬æ¬¡ç‚¹å‡»
          lastTapTime = currentTime;
          lastTapPosition = currentPosition;
          break;
        }
        
        default:
          statusElement.textContent = 'çŠ¶æ€: ç­‰å¾…æ‰‹åŠ¿';
          cursor.style.display = 'none';
          isPinching = false;
      }
    }
    
    // åˆå§‹åŒ– MediaPipe Hands
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.5
    });
    
    hands.onResults(results => {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
      
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
          color: '#0000FF', 
          lineWidth: 1
        });
        drawLandmarks(canvasCtx, landmarks, {
          color: '#FF0000', 
          lineWidth: 1,
          radius: 2
        });
        
        const gesture = recognizeGesture(landmarks);
        performGesture(gesture);
      } else {
        cursor.style.display = 'none';
        statusElement.textContent = 'çŠ¶æ€: æœªæ£€æµ‹åˆ°æ‰‹';
        isPinching = false;
      }
      
      canvasCtx.restore();
    });
    
    // å¯åŠ¨æ‘„åƒå¤´
    const camera = new Camera(videoElement, {
      onFrame: async () => await hands.send({image: videoElement}),
      width: 640,
      height: 480
    });
    camera.start();
  </script>
</body>
</html>
